import os
import time
import random
import configparser
from threading import Thread
from pyrogram import Client, filters
from pyrogram.errors import FloodWait, UserAlreadyParticipant, ChannelPrivate, UsernameNotOccupied

# Configuration
config = configparser.ConfigParser()
config.read('config.ini')

# Load settings
try:
    API_ID = config.getint('SETTINGS', 'API_ID')
    API_HASH = config.get('SETTINGS', 'API_HASH')
    JOIN_INTERVAL = config.getint('TIMINGS', 'JOIN_INTERVAL')
    LEAVE_INTERVAL = config.getint('TIMINGS', 'LEAVE_INTERVAL')
    JOIN_COUNT = config.getint('ACTIONS', 'JOIN_COUNT')
    LEAVE_COUNT = config.getint('ACTIONS', 'LEAVE_COUNT')
    CHANNEL_LINK = config.get('TARGET', 'CHANNEL_LINK')
except Exception as e:
    print(f"Error reading config: {e}")
    exit()

# Ensure data directory exists
DATA_DIR = 'data'
os.makedirs(DATA_DIR, exist_ok=True)

def get_session_files():
    """Get all .session files in data directory"""
    return [f for f in os.listdir(DATA_DIR) if f.endswith('.session')]

def create_client(session_name):
    """Create a Pyrogram client instance"""
    session_path = os.path.join(DATA_DIR, session_name)
    return Client(
        session_name.split('.')[0],
        api_id=API_ID,
        api_hash=API_HASH,
        workdir=DATA_DIR,
        plugins=dict(root="plugins")
    )

def manage_account(session_file):
    """Manage a single Telegram account"""
    app = create_client(session_file)
    
    try:
        with app:
            # Bring account online
            print(f"[{session_file}] Account is online")
            
            # Join channel
            try:
                app.join_chat(CHANNEL_LINK)
                print(f"[{session_file}] Successfully joined channel")
                
                # Wait configured time before leaving
                time.sleep(JOIN_INTERVAL)
                
                # Leave channel
                app.leave_chat(CHANNEL_LINK)
                print(f"[{session_file}] Successfully left channel")
                
                # Bring account back online after leaving
                print(f"[{session_file}] Account is online again")
                
            except UserAlreadyParticipant:
                print(f"[{session_file}] Already in channel")
            except (ChannelPrivate, UsernameNotOccupied):
                print(f"[{session_file}] Channel is private or doesn't exist")
            except FloodWait as e:
                print(f"[{session_file}] Flood wait: {e.x} seconds")
                time.sleep(e.x)
            except Exception as e:
                print(f"[{session_file}] Error: {e}")
                
    except Exception as e:
        print(f"[{session_file}] Failed to initialize: {e}")

def main():
    session_files = get_session_files()
    if not session_files:
        print("No session files found in data directory")
        return
    
    print(f"Found {len(session_files)} accounts")
    
    # Process accounts in batches
    while True:
        # Join accounts
        print(f"\nJoining {JOIN_COUNT} accounts...")
        join_threads = []
        for session in session_files[:JOIN_COUNT]:
            t = Thread(target=manage_account, args=(session,))
            t.start()
            join_threads.append(t)
            time.sleep(random.uniform(1, 3))  # Small delay between starts
            
        for t in join_threads:
            t.join()
            
        time.sleep(JOIN_INTERVAL)
        
        # Leave accounts
        print(f"\nLeaving {LEAVE_COUNT} accounts...")
        leave_threads = []
        for session in session_files[:LEAVE_COUNT]:
            t = Thread(target=manage_account, args=(session,))
            t.start()
            leave_threads.append(t)
            time.sleep(random.uniform(1, 3))  # Small delay between starts
            
        for t in leave_threads:
            t.join()
            
        time.sleep(LEAVE_INTERVAL)

if __name__ == "__main__":
    main()